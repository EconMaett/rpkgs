# Chapter 11 - Dependencies: In Practice ----

# Different types of dependencies exist within the different parts of your package:
# - in your functions, below `pkg/R/`
# - in your tests, below `pkg/tests/testthat/`
# - in your examples, in the help topics, below `pkg/man/`
# - in your vignettes and articles, below `pkg/vignettes/`


## 11.1 Confusion about `Imports` ----

#   Listing a package in the `Imports` filed of the `DESCRIPTION` file does NOT "import" that package.

# The `Imports` field of the `DESCRIPTION` file ensures the packages listed there
# are installed when your package is installed.

# It is neither automatic nor advisable that a package listed in the `Imports` field
# of the `DESCRIPTION` file also appear in the `imports()` or `importFrom()` directives.

# Packages can be listed in the `Imports` field of the `DESCRIPTION` file
# but not in the directives of the `NAMESPACE` file.

# The converse is not true. Every package mentioned by a directive in the `NAMESPACE`
# file must be present in the `Imports` or `Depends` field of the `DESCRIPTION` file.


## 11.2 Conventions for this chapter ----

# When talking about generic package functions, the following conventions apply:

# - `pkg`: the name of a hypothetical package

# - `aaapkg` or `bbbpkg`: the names of hypothetical packages your package depends on

# - `aaa_fun()`: the name of a function exported by `aaapkg`


## 11.3 `NAMESPACE` Workflow ----

# You generate the `NAMESPACE` file with special "roxygen comments" (`#' @export`)
# above the objects inside the `pkg/R/*.R` files.

# The roxygen comments are also the basis of the package's help files in `R/man/`.

# The `NAMESPACE` file starts with a single commented-out line:
# `# Generated by roxygen2: do not edit by hand`

# As you incorporate roxygen tax to export and import functions, you need to
# re-generate the `NAMESPACE` file periodically.

# 1. Add namespace-related tags to the roxygen comments to your `pkg/R/*.R` files:
#' @importFrom aaapkg aaa_fun
#' @import bbbpkg
#' @export
foo <- function(x, y, z) {
  # ...
}

# 2. Run `devtools::document()` or press Ctrl + Shift + D in R Studio to "document" your package:
#   - The help topics in the `pkg/man/*.Rd` files are updated.
#   - The `NAMESPACE` file is re-generated:
# Generated by roxygen2: do not edit by hand
# 
# export(foo)
# import(bbbpkg)
# importFrom(aaapkg, aaa_fun)

# The "roxygen2" package will insert the appropriate directives into the `NAMESPACE` file
# and will determine whether to use `export()` or `S3method()`.


## 11.4 Package is listed in `Imports` ----

# Consider a dependency listed in the `Imports` field of the `DESCRIPTION` file:
# Imports:
#   aaapkg

# The code inside your package can assume that the package "aaapkg" is installed
# whenever your new packge "pkg" is installed.


### 11.4.1 In code below R/ ----

# The recommended default is to call external functions using the
# `package::function()` syntax:
somefunction <- function(...) {
  # ...
  x <- aaapkg::aaa_fun(...)
  # ...
}

# It is recommended to *not* importing anything from "aaapkg" into your namespace.

# This makes it easy to identify functions that live outside of your package,
# which is useful when you read the code in the future.
# It also eliminates any name conflicts between "aaapkg" and "pkg".

# There are some exceptions to this rule:

# - An operator: You can't access operators with the `package::function()` syntax,
#   so you must import the whole package.
#   Examples are the null-coalescing operator `%||%` from the "rlang" package
#   or the original pip `%>%` from the "magrittr" package.

# - A function that you use a *lot*. This can be handy when generating user-facing
#   messanges, because it is more likely that lines in the source correspond to lines
#   in the output.

# - A function that you call in a tight loop: There is a small performance penalty
#   associated with the `package::function()` syntax, on hte order of 100 nanoseconds,
#   so this will only matter if you clal the function millions of times.

# Use `usethis::use_import_from()` for interactive workflow.

usethis::use_import_from(package = "glue", fun = "glue_collapse")
# will write the roxygen tag into the source code of your package:
#' @importFrom glue glue_collapse

# This roxygen tag has two reasonable locations:

# - As close as possible to the usage of the external function.
#   Place `#' @importFrom` above the function in your package where you use the
#   external function. This will become cumbersome over time.

# - In a central location. This keeps all `#' @importFrom` tags together,
#   in a dedicated section of the package-level documentation file, which you
#   create with `usethis::use_package_doc()`.
#   This is already implemented with `usethis::use_imports_from()`.
#   In `pkg/R/pkg-package.R` you will see:
# The following block is used by usethis to automatically manage
# roxygen namespace tags. Modify with care!
## usethis namespace: start
#' @importFrom glue glue_collapse
## usethis namespace: end
NULL

# `devtools::document()` processes the roxygen comments and writes help topics
# to `pkg/man/*.Rd` and generates the `NAMESPACE` file with the appropriate directives.

# Using `usethis::imports_from(package, function)` does this for you and
# also calls `devtools::load_all()`, making the newly imported function available in your
# current R session.


# The roxygen tag from above causes the following directive to appear in the `NAMESPACE` file:
# `importFrom(glue, glue_collapse)`

# Then you can start using the function directly in your code:
somefunction <- function(...) {
  ...
  x <- glue_collapse(...)
  ...
}

# The only package you should import entirely into your namespace is
# the "rlang" package if you are writing tidyverse-extending packages.
# It functions like the "base" package for "tidyverse".

# The roxygen tag that imports all of "rlang"  is
#' @import rlang

# It should appear in `pkg/R/*.R` and ideally inside a dedicated space
# `pkg/R/pkg-package.R`, which you generated with `usethis::use_package_doc()`.

# After calling `devtools::document()`, the directive
# `import(rlang)`
# will then appear in your `NAMESPACE` file.


#### 11.4.1.1 How *not* to use a package in `Imports` ----

# Sometimes a package is listed in the `Imports` field of your `DESCRIPTION` file
# but R does not think you use it, leading to a `NOTE` from `R CMD check`:
# * checking dependencies in R code ... NOTE
# Namespace in Imports field not imported from: 'aaapkg'
#   All declared Imports should be used.

# This happens if you need to list an indirect dependency in the `Imports` field,
# perhaps to state a minimum version for it with `usethis::use_package(package name, minversion = TRUE)`.

# The tidyverse-meta-package has this problem on a large scale, since it mostly exists to
# install a bundle of packages at specific versions.

# There are various situations where it is not obvious that your package
# truly needs every package listed in the `Imports` field, but in fact does.

# How can you get rid of this `NOTE`?

# The solution is to put a namespace-qualified reference (not a call) to an object
# in "aapkg" in some file below `pkg/R/`, such as a `pkg/R/*.R` file associated
# with package-wide setup:
ignore_unused_imports <- function() {
  aaapkg::aaa_fun
}

# You do not need to call `ignore_unused_imports()` anywhere and you should
# not export it.
# It does not have to exercise `aaapkg::aaa_fun()`.
# This function only exists so that R believes you actually used
# the package "aaapkg" listed in the `Imports` field of your `DESCRIPTION` file.

# You can also suppress this `NOTE` by using the roxygen tag
# `#' @importFrom aaapkg aaa_fun` but in that case, the whole "aaapkg" will be
# loaded whenever your own package "pgk" is loaded.


### 11.4.2 In test code ----

# In your tests under `pkg/tests/testthat` you will also use the `aaapkg::aaa_fun()`
# syntax just like you would inside of `pkg/R/*.R`.

# Do not use `library(aaapkg)` to attach one of your dependencies
# inside of your test files, as it makes the search path in your tests
# different from the rest of the package so the tests cease to be representative.


### 11.4.3 In examples and vignettes ----

# In vignettes on the other hand, you will need to attach a package
# that appears in the `Imports` field of your `DESCRIPTION` file
# with the `library(aaapkg)` command and use the `aaapkg::aaa_fun()` syntax
# to use it.


## 11.5 Package is listed in `Suggests` ----

# Consider a dependency listed in the `Suggests` field of the `DESCRIPTION` file:
# Suggests:
#   aaapkg

# You can NOT assume that every user has installed "aaapkg", only that the developer
# (aka you!) has.
# Most functions that are used to install packages support a `dependencies = TRUE`
# argument that controls whether to install just the hard dependencies or
# to also install the suggested packages:
# - `install.packages(dependencies = TRUE)`
# - `remotes::install_github(dependencies = TRUE)`
# - `pak::pkg_install(dependencies = TRUE)`


### 11.5.1 In code below `R/` ----

# Inside a function in your own package, check for the availability of a suggested
# package with `requireNamespace("aaapkg", quietly = TRUE)`.
# There are two scenarios:
# 1) The dependency is absolutely required
# 2) Your package offers some sort of fallback behavior

# 1) The suggested package is required
my_fun <- function(a, b) {
  if (!requireNamespace("aaapkg", quietly = TRUE)) {
    stop(
      "Package 'aaapkg' mustbe installed to use this function.",
      call. = FALSE
    )
  }
  # code that includes calls such as `aaapkg::aaa_fun()`
}

# 2) The suggested package is optonal; a fallback method is provided
my_fun <- function(a, b) {
  if (requireNamespace("aaapkg", quietly = TRUE)) {
    aaapkg::aaa_fun()
  } else {
    g()
  }
}

# The "rlang" package has useful functions to check package availability:
# - `rlang::check_installed()`
# - `rlang::is_installed()`

# 1) The suggested package is required
my_fun <- function(a, b) {
  rlang::check_installed(pkg = "aaapkg", reason = "to use `aaa_fun()`")
  # code that includes calls such as `aaapkg::aaa_fun()`
}

# 2) The suggested package is optional; a fallback method is provided
my_fun <- function(a, b) {
  if (rlang::is_installed(pkg = "aaapkg")) {
    aaapkg::aaa_fun()
  } else {
    g()
  }
}

# These "rlang" functions can vectorize over `pkg` and have
# classed errors with a data payload, and, for `rlang::check_installed()`,
# offer to install the needed package.


### 11.5.2 In test code ---

# The tidyverse team writes tests as if all suggested packages are available.
# That is, they use them unconditionally in the tests.

# This imposes self-consistency and pragmatism.
# The "testthat" package appears in the `Suggests` field of the `DESCRIPTION` file,
# and *not* in the `Imports` field.

# Therefore, if the tests are executing, that implies that an expansive notion of
# package dependencies has been applied.

# Empirically, in every scenario of running `R CMD check`,
# the suggested packages are installed.

# This is true for CRAN.

# An exception is this test from the "ggplot2" package where
# a suggested package is guarded in a test that uses
# `testthat::skip_if_not_installed()` to skip the execution if a suggested
# package is unavailable:
library(testthat)
test_that(desc = "basic plot builds without error", code = {
  skip_if_not_installed(pkg = "sf")
  
  nc_tiny_coords <- matrix(
    c(-81.473, -81.741, -81.67, -81.345, -81.266, -81.24, -81.473,
      36.234, 36.392, 36.59, 36.573, 36.437, 36.365, 36.234),
    ncol = 2
  )
  
  nc <- sf::st_as_sf(
    data_frame(
      NAME = "ashe",
      geometry = sf::st_sfc(f::st_polygon(list(nc_tiny_coords)), crs = 4326)
    )
  )
  
  expect_identical(object = "sf-polygons", expected = ggplot(nc) + geom_sf() + coord_sf())
})

# The "sf" package can be nontrivial to install and it is conceivable that
# a contributor to the "ggplot2" package would want to execute the
# remaining tests even if "sf" is not available.

# Note that `testthat::skip_if_not_installed(pkg, minimum_version = "x.y.z")`
# can be used to skip a test based on the version of the other package.


### 11.5.3 In examples and vignettes ----

# A common place to sue a package listed in the `Suggests` field of the `DESCRIPTION` file
# is an example where we guard with `require()` and `requireNamespace()`.

# An example from `ggplot2::coord_map()` where the "maps" package is
# listed in the `Suggests` field of the `DESCRIPTION` file of "ggplot2":
#' @examples
#' if (require("maps")) {
#'   nz <- map_data("nz")
#'   # Prepare a map of NZ
#'   nzmap <- ggplot(data = nz, mapping = aes(x = long, y = lat, group = group)) +
#'     geom_polygon(fill = "white", colour = "black")
#'     
#'     # Plot it in carteesian coordinates
#'     nzmap
#' }

# An example is the only place where you would ever use `require()` inside of a package.

# The key packages needed to build vignettes are "rmarkdown" and "knitr"
# which need to be listed in the `Suggests` field of the `DESCRIPTION` file of your package.


## 11.6 Package is listed in `Depends` ----

# Consider a dependency listed in the `Depends` field of your `DESCRIPTION` file:
# Depends:
#   aaapkg

# The only difference to the more common 
# Imports:
#   aaapkg
# is that "aapkg" will be attached whenever your package is attached.


### 11.6.1 In code below `pkg/R/` and in test code ----

# You have the same options as with a package listed in the `Imports` field:
# - Use `aaapkg::aaa_fun()` syntax

# - Import a function with the `#' @importFrom aaa_fun` roxygen tag and call
#   `aaa_fun()` directly

# - Import the entire "aaapkg" namespace with the `@import aaapkg` roxygen tag
#   and call `aaa_fun()` directly.


### 11.6.2 In examples and vignettes ----


# This is the most obvious difference with a dependency in `Depends`
# versus `Imports`.
# Since your own package "pgk" is attached when your examples are executed,
# so is the package "aaapkg" listed in `Depends`.
# You do NOT have to attach it explicitly with `library(aaapkg)`.

# The "ggforce" package `Depends` on "ggplot2" and examples for 
# `ggforce::geom_mark_rect()` use functions like `ggplot2::gpplot()`
# and `ggplot2::geom_point()` without any explicit call to `library(ggplot2)`:
ggplot(data = iris, mapping = aes(x = Petal.Length, y = Petal.Width)) +
  geom_mark_rect(mapping = aes(fill = Species, filter = Species != "versicolor")) +
  geom_point()
# example continues ....

# The first line of code executed in one of your vignettes is probably
# `library(pkg)` which attaches your own package "pkg" and as a side-effect,
# also attaches any dependencies listed in the `Depends` field of your `DESCRIPTION` file.

# You do not need to explicitly attach the dependency before using it,
# i.e. you do NOT need to call `library(aaapkg)`.

# Consider the "censored" package that `Depends` on the "survival" package
# and the code in `vignette("examples", package = "censored")` starts out like so:
library(tidymodels)
library(censored)
#> Loading required package: survival

# vignette continues ....


## 11.7 Package is a nonstandard dependency ----

### 11.7.1 Depending on the development version of a package ----

# The `Remotes` field in the `DESCRIPTION` file is used to install
# a dependency from a place other than CRAN or Bioconductor.

# A common example is when you are developing a second package that depends
# on your first package which is not yet on CRAN.


# The "devtools" vignette and the "pak" help page describes how to use
# such sources.

# The dependency and a minimum version requirement still need to
# be declared in the `Imports` field of the `DESCRIPTION` file.
# Instead of `usethis::use_package(pkg, minversion = TRUE)`,
# you will use `usethis::use_dev_package()`.
# If your package "pkg" temporarily relies on a development version of "aaapkg",
# the affected `DESCRIPTION` fields will evolve over time:

# 1) Stable
# Package: pkg
# Version: 1.0.0
# Imports:
#   aaapkg (>= 2.1.3)

# 2) Dev
# Package: pkg
# Version: 1.0.0.9000
# Imports:
#   aaapkg (>= 2.1.3.9000)
# Remotes:
#   jane/aaapkg

# 3) Stable again
# Package: pkg
# Version: 1.1.0
# Imports:
#   aaapkg (>= 2.2.0)

# You can not submit your package "pkg" to CRAN as long as it has
# a `Remotes` field in the `DESCRIPTION` file, i.e. as long as "pgk" 
# depends on another package "aaapkg" that is not available on CRAN
# or Bioconductor.


### 11.7.2 `Config/Needs/*` field ----

# The `Config/Needs/*` field in the `DESCRIPTION` file is not directly related
# to "devtools" but associated with continuous workflow integration
# made available to the community at https:://github.com/r-lib/actions/
# and exposed via functions such as `usethis::use_github_actions()`.

# A `Config/Needs/*` field in `DESCRIPTION` tells the `setup-r-dependencies`
# about extra packages that need to be installed.

# `Config/Needs/website` is the most common such field in `DESCRIPTION`
# and provides a place to specify packages that are not normally a formal
# dependency but that must be present in order to build the package's website.

# The "readxl" package is a good example since it has a non-vignette article on
# workflows that shows "readxl" working in concert with other "tidyverse" packages
# such as "readr" and "purrr".

# The "readxl" package has the following `Config/Needs/website` field
# in its `DESCRIPTION` file to indicate that the "tidyverse" is needed 
# to build the website, which is also formatted with styling that lives in
# the `tidyverse/template` GitHub repository:
# Config/Needs/website:
#   tidyverse,
#   tidyverse/tidytemplate

# The corresponding excerpt from the configuration of the workflow that builds
# and deploys the website in `.github/workflows/pkgdown.yaml` is:
# - uses: r-lib/actions/setup-r-dependencies@v2
#   with:
#     extra-packages: pkgdown
#     needs: website


## 11.8 Exports ----

# For a function to be usable outside of your package, you must **export** it.
# When you create a new package with `usethis::create_package()`,
# nothing is exported.
# You can experiment interactively with `devtools::load_all()`,
# since that loads all functions from your package source.
# But once you install and attach the package with 
# `devtools::install("pkg")` and `library(pkg)`, 
# only the exported functions will be available in a fresh R session.


### 11.8.1 What to export ----

# Only export functions you want other people to use.
# Exported functions must be properly documented,
# and you must be cautious when changing their interface.

# It is better to export too little than too much.

# Packages should thrive to do *one thing* and do that one thing *well*


# Any functions not related to the package's core purpose should not
# be exported, like the functions in your `pkg/R/utils.R` file.

# If your package has a function that could be of interest to
# developers extending your package, combine the roxygen tags
# `#' @export` and `@keywords internal`.

# The `internal` keyword keeps the function from appearing in the package
# index, but the associated help topic still exists and the functions appears
# among the exported functions in the `NAMESPACE` file.


### 11.8.s Re-exporting ----

# Sometimes you want to make something available to the users of your package
# that is provided by one of your dependencies.

# A blueprint for re-exporting an object from another package
# is the `sessioninfo::session_info()` function:

# 1. List the package that hosts the re-exported object in the `Imports`
#    field of your `DESCRIPTION` file:
# Imports:
#   sessioninfo

# 2. In one of your `pkg/R/*.R` files, have a reference to the target 
#    function, preceded by roxygen tags for both importing and exporting:
#' @export
#' @importFrom sessioninfo session_info
sessioninfo::session_info

# That's it! Next time you re-generate `NAMESPACE` with `devtools::document()`,
# the following two lines will appear:
# export(session_info)
# importFrom(sessioninfo,session_info)

# This will also create the `pkg/man/reexports.Rd` file.
# This help topic lists all re-exported objects and links to their primary documentation.


## 11.9 Imports and exports related to S3 -----

# R has multiple object-oriented programming (OOP) systems.

# - S3 is the most important. Study the S3 chapter of Advanced R and the "vctrs" package.

# - S4 is important in the Bioconductor community.

# - R6 is used in many "tidyverse" packages.

# - S7 is based on S3 objects and methods.

# For the S3 OOP, consider generic functions and their class-specific 
# implementations, known as methods.

# If your package "owns" an S3 class, it makes sense to export a user-friendly
# constructor function.

# For S3, this is just a regular function.


# If your package "owns" an S3 generic function and you want others
# to be able to use it, you need to export this generic functions.

# The "dplyr" package exports the generic function `dplyr::count()`
# and implements and exports a specific method, `count.data.frame()`:
#' .... all the usual documentation for count() ....

#' # Export the generic function
#' @export
count <- function(x, ..., wt = NULL, sort = FALSE, name = NULL) {
  UseMethod(generic = "count")
}

#' Export a specific method
#' @export
count.data.frame <- function(
    x,
    ...,
    wt = NULL,
    sort = FALSE,
    .drop = group_by_drop_default(x)) { ... }

# The corresponding directives in "dplyr"'s `NAMESPACE` file are:
# S3method(count,data.frame)
# export(count)

# Assuming your package "pkg" implements a new method for the generic
# function `count()` for a class of your own.

# The "dbplyr" package implements a method for the generic function `count()`
# for objects of the class `tbl_lazy`.

# An add-on package that implements an S3 generic for a new class 
# needs to list the package that provides the generic function in the
# `Imports` field of its `DESCRIPTION` file, to import the generic into
# its namespace, and export its own S3 method.

# Therefore, the `Imports` field in the `DESCRIPTION` file of the "dbplyr" package includes:
# Imports:
#   dplyr, 

# And inside of `dbplyr/R/verb-count.R`, we have:
#' @importFrom dplyr count
#' @export
count.tbl_lazy <- function(x, ..., wt = NULL, sort = FALSE, name = NULL) { ... }

# And the `NAMESPACE` file of "dbplyr" includes the directives:
# S3method(count,tbl_lazy)
# importFrom(dplyr,count)

# Since the "dbplyr" package also provides methods for various
# generic functions provided by the "base" package, such as
# `dim()` and `names()`, there is no need to import those generics,
# but it is still necessary to export the methods.

# In `dbplyr/R/tbl_lazy.R`, we have:
#' @export
dim.tbl_lazy <- function(x) {
  c(NA, length(op_vars(x$lazy_query)))
}

#' @export
names.tbl_lazy <- function(x) {
  colnames(x)
}

# And the `NAMESPACE` file of the "dbplyr" package includes the directives:
# S3method(dim,tbl_lazy)
# S3method(names,tbl_lazy)


# The trickiest case is when your package offers a new method for a 
# generic function that is owned by a package that is listed
# as a dependency in the `Suggests` field of your `DESCRIPTION` file.

# You want to register the availability of your S3 method conditionally,
# when your package is being loaded.

# If the suggested package is present, your new S3 method should be
# registered, but if the package is not present, it should not be registered.

# Within the "tidyverse", the "glue" package is managed as a low-level
# package that should have minimal dependencies.

# "glue" functions generally return a character vector that also has
# the S3 class "glue"
library(glue)
name <- "Betty"
(ret <- glue("My name is {name}."))
# My name is Betty.
class(ret)
# "glue" "character"

# The S3 class "glue" allows methods from the "glue" package to
# offer special methods for `print()`, the `+` operator,
# and subsetting with `[` and `[[`.

# A downside is that this class attribute "glue" complicates string
# comparisons:
identical(x = ret, y = "My name is Betty.")
# FALSE

all.equal(target = ret, current = "My name is Betty.")
# FALSE

# Therefore, for testing, the "glue" package offers a method for
# the generic function `thestthat::compare()`:
testthat::expect_equal(object = ret, expected = "My name is Betty.")
# No error

# But the "glue" package can't list the "testthat" package in `Imports`,
# which would defeat its purpose of being a light-dependencies package.

# So the "testthat" package must go into the `Suggests` field of "glue"'s
# `DESCRIPTION` file instead.

# The solution is to register the new method when "glue" is loaded.
# This is done in the special `.onLoad()` function:
library(vctrs)
.onLoad() <- function(...) {
  s3_register(generic = "testthat::compare", class = "glue")
  s3_register(generic = "waldo::compare_proxy", class = "glue")
  s3_register(generic = "vctrs::vec_ptype2", class = "glue.glue")
  invisible()
}

# The `s3_register()` function comes form the "vctrs" package.

# If you don't need to depend on the "vctrs" package, simply inline
# the `s3_register()` source into your own package.

# In this case you are allowed to simply copy and paste code from
# others into yours.

# This usage is specifically allowed by the license of the source code
# of `vctrs::s3_register()`.

# END