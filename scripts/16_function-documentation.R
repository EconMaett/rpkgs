# Chapter 16 - function documentation -----

# This chapter introduces function documentation that users access with
# `?somefunction` or `help("somefunction")`.

# Base R provides a standard way of documenting a package,
# where each function is documented in a **topic**,
# an `.Rd` file ("R documentation") in the `pkg/man/` directory.

# `.Rd` files use a custom syntax, loosely based on LaTeX,
# and can be rendered to HTML, plain text, or PDFs, as needed.


# In the "devtools" ecosystem, we do not edit `.Rd` files directly.

# Instead, we use specially formatted "roxygen comments" above
# the source code for each function.

# Then we use the "roxygen2" package to generate the `.Rd` files.
# The advantages are:

# - Code and documentation are co-located. When you modify code,
#   you can also update your documentation.

# - You can use markdown, rather than having to learn a one-off markup
#   language that only applies to `.Rd` files.
#   Additionally, the automatic hyper-linking functionality makes it easier
#   to crate richly linked documentation.

# - There is a lot of `.Rd` boilerplate that is automated away.


# - "roxygen2" provides a number of tools for sharing content across documentation
#   topics and even between topics and vignettes.


# This chapter focuses on documenting functions, but the same
# recommendations apply to documenting
# - data sets
# - classes
# - generic functions
# - packages

# Learn more about those other important topics in
vignette("rd-other", package = "roxygen2")


## 16.1 "roxygen2" basics ----

### 16.1.1 The documentation workflow ----

# Unlike with "testthat", there is no opening move to declare that
# you are going to use "roxygen2" for documentation.

# Your documentation workflow begins when you start to add roxygen comments
# above your function.
# These always start with `#'`:
#' together two numbers
#' 
#' @param x A number
#' @param y A number
#' @returns A numeric vector
#' @examples
#' add(1, 1)
#' add(10, 1)
add <- function(x, y) {
  return(x + y)
}

# In RStudio, you write the function first, then put the cursor
# inside the function and click "Code" -> "Insert Roxygen Skeleton".

# Once you have at least one roxygen comment, run
# `devtools::document()` to generate or uptdate your package's `.Rd` files.

# Under the hood, this calls `roxygen2::roxygenise()`.
# The roxygen block above generates the file `pkg/man/add.Rd`:
# % Generated by roxygen2: do not edit by hand
# % Please edit documentation in `R/add.R`
# \name{add}
# \alias{add}
# \title{Add together two numbers}
# \usage{
# add(x, y)
# }
# \arguments{
# \item{x}{A number.}
# \item{y}{A number.}
# }
# \value{
# A numeric vector.
# }
# \description{
# Add together two numbers
# }
# \examples{
# add(1, 1)
# add(10, 1)
# }


# You can also run `devtools::document()` with the keyboard
# shortcut Ctrl + Shift + D.

# When you run `?add`, `help("add")`, or `example("add")`,
# R looks for an `.Rd` file containing 
# `\alias{add}`.
# It then parses this file, converts it to HTML and displays it.


# Note that you should document ALL exported functions and
# data sets. Else you will get a `WARNING` from `R CMD check`.

# Conversely, you probably do not want to document un-exported functions.
# If you want to use roxygen comments for internal documentation, 
# use the 
#' @noRd
# roxygen tag to suppress the creation of the `.Rd` file.


# You may have noticed that your `DESCRIPTION` file includes the
# field `Roxygen: list(markdown = TRUE)`.

# "devtools"/"usethis" includes this field by default when initiating
# a `DESCRIPTION` file and gibes "roxygen2" a heads-up that your package uses
# markdown syntax in its roxygen comments.


# The base R, default help-seeking process looks inside **installed**
# packages to see your package's documentation during development.

# "devtools" overrides the usual help functions with modified versions
# that know to consult the current **source** package.

# To activate these overrides, you run `devtools::load_all()` at least once.

# You may need to re-generate your `.Rd` files with `devtools::document()` first.

# Then you can call `?function` to see "Rendering development documentation...".



### 16.1.2 "roxygen2" comments, blocks, and tags ----

# "roxygen2" comments start with `#'` and all "roxygen2" comments 
# preceding a function are collectively called a **block**.


# Blocks are broken up by **tags**, which look like 
# `#' @tagName tagValue`, and the content of a tag extends from the end
# of the tag name to the start of the next tag.


# A block can contain text before the first tag which is called the
# **introduction**.


# By default, each block generates a single documentation **topic**,
# i.e. a single `.Rd` file in the `pkg/man/` directory.


# Throughout this chapter we show "roxygen2" comments from real "tidyverse"
# packages such as "stringr":
library(stringr)


# The documentation for `stringr::str_unique()` reads:
#' Remove duplicated strings
#' 
#' `str_unique()` removes duplicated values, with optional control over
#' how duplication is measured.
#' 
#' @param string Input vector. Either a character vector, or something
#' coercible to one.
#' @param ... Other options used to control matching behavior between
#' strings. Passed on to [stringi::stri_opts_collator()].
#' @returns A character vector, usually shorter than `string`.
#' @seealso [unique()], [stringi::stri_unique()] which this function wraps
#' @examples
#' str_unique(c("a", "b", "c", "b", "a"))
#' 
#' # Use ... to pass additional arguments to stri_unique()
#' str_unique(c("motley", "mötley", "pinguino", "pingüino"))
#' str_unique(c("motley", "mötley", "pinguino", "inpüino"), strength = 1)
#' @export
str_unique <- function(string, ...) {
  # ...
}


# The introduction is followed by five tags:
# - `@param`s
# - `@returns`
# - `@seealso`
# - `@examples`
# - `@export`


# Try "Code" -> "Reflow Comment" or the keyboard shortcut
# Ctrl + Shift + / to manage the line length of roxygen comments.



# The order in which the tags appear in your roxygen comments
# does not dictate the order in which they are rendered in the
# documentation.

# The order of presentation is determined by tooling within "base" R.



### 16.1.3 Key markdown features ----

# **Backticks for inline code:** Use backticks to format a piece of text
# as code i.e. in a fixed with font. Example:
#' I like `thisfunction()`, because it is great.


# **Square brackets for an auto-linked function:** Enclose text like
# `somefunction()` and `somepackage::somefunction()` in square brackets
# (`[]`) to get an automatic link to that function's documentation.

# Be sure to include the trailing parentheses, because it is good
# style and causes the function to be formatted as code,
# i.e. you don0t need to add backticks:
#' It is obvious that `thisfunction()` is better than [otherpkg::otherfunction()]
#' or even our own [olderfunction()].


# **Vignettes:** If you refer to a vignette with an iline call to 
# `vignette("some-topic")`, it serves a dual purpose.

# First, this is literally the R code you would execute to view a 
# vignette locally.

# In many rendered contexts, this becomes a hyperlink to that same
# vignette in a "pkgdown" website.

# Here we use that to link to some relevant vignettes:

# - `vignette("rd-formatting", package = "roxygen2")`

# - `vignette("reuse", package = "roxygen2")`

# - `vignette("linking", package = "pkgdown")`


# **Lists:** Bullet lists break up the dreaded "wall of text" and make
# your documentation easier to scan.

# Use them in the description of the function or of an argument
# and also for the return value.

# It is not necessary to include a blank line before the list, but 
# that is also allowed.

#' Best features of `thisfunction()`
#' * Smells nice
#' * Has good vibes


## 16.2 Title, description, details ----

# While it is possible to use explicit tags in the introduction,
# we can rely on implicit tags:

# - The **title** is taken from the first sentence.
#   It should be written in sentence case, not end in a full stop,
#   and be followed by a blank line.
#   The tile is shown in function indexes like `help(package = "somepackage")`.


# - The **description** is taken from the next paragraph.
#   It is shown at the top of the documentation and should
#   briefly introduce the most important features of the function.


# - Additional **details** are anything after the description.
#   Details are optional, but can be of any length.


### 16.2.1 Title ----

# The title will appear in the **reference index**.

# The titles for the functions in the "stringr" package are rather too long.

# In contrast, the titles form the "dplyr" package are much better:

# - `mutate()`: Create, modify, and delete columns
# - `summarize()`: Summarize each group down to one row
# - `filter()`: Keep rows that match a condition
# - `select()`: Keep or drop columns using their names and types.
# - `arrange()`: Order rows using column values


### 16.2.2 Description ----

# A description should summarize the goal of the function in a 
# single paragraph.

# `stringr::str_detect()`'s description reads:
#' Detect the presence/absence of a match
#' 
#' `str_detect()` returns a logical vector with `TRUE` for each element in
#' # `string` that matches `pattern` and `FALSE` otherwise. It's equal to
#' `grepl(pattern, string)`.


# If you want more than one paragraph, you need to use an explicit
# `#' @description` tag to prevent the second and subsequent paragraphs
# from being turned into the `#' @details`.

# A two-paragraph `#' @description` from `stringr::str_view()` reads:
#' View strings and matches
#' 
#' @description
#' `str_view()` is used to print the underlying representation of a string and
#' to see how a `pattern` matches.
#' 
#' Matches are surrounded by `<>` and unusual whitespace (i.e. all whitespace
#' apart from `""` and `"\n"`) are surrounded by `{}` and escaped. Where
#' possible, matches and unusual whitespace are colored blue and `NA`s red.


# Another example description form `stringr::str_like()` which
# uses a bullet list in `#' @description` reads:
#' Detect a pattern in the same way as `SQL`'s `LIKE operator
#' 
#' @description
#' `str_like()` follows the conventions of the SQL `LIKE` operator:
#' 
#'  * Must match the entire string.
#'  * `_` matches a single character (like `.`).
#'  * `%` matches any number of characters (like `.*`).
#'  * `\%` and `\_` match literal `%` and `_`.
#'  * The match is case insensitive by default.



### 16.2.3 Details ----

# The `#' @details` include any additional details and explanations you think
# a user might find useful.


# An example for `#' @details` from `dplyr::mutate()` reads:
#' Create, modify, and delete columns
#' 
#' `mutate()` creates new columns that are functions of existing variables.
#' It can also modify (if the name is the same as an existing 
#' column) and delete columns (by setting their value to `NULL`).
#' 
#' @section Useful mutate functions:
#' 
#' * [`+`], [`-`], [log()], etc. for their usual mathematical meanings
#' 
#' ...
#' 
#' @section Grouped tibbles:
#' 
#' Because mutating expressions are computed within groups, they may
#' yield different results on grouped tibbles. This will be the case
#' as soon as an aggregating, lagging, or ranking function is
#' involved. Compare this un-grouped mutate:
#' 
#' ...



## 16.3 Arguments ----

# Use `#' @param`, short for "parameter", a synonym for "argument",
# followed by the argument name, and a description of its action.


# The priority is to provide a succinct summary of the allowed inputs 
# and what the parameter does.

# For example, here is how `stringr::str_detect()` documents the
# main argument `string`:
#' @param string Input vector. Either a character vector, or something
#' coercible to one.


# And here are the three arguments to `stringr::str_flatten()`:
#' @param collapse String to insert between each piece. Defaults to `""`.
#' @param last Optional string to use in place of the final separator.
#' @param na.rm Remove missing values? If `FALSE` (the default), the result
#'    will be `NA` if any element of `string` is `NA`.


# It is good practice to describe the default arguments, as is the
# case in `@param collapse` and `@param na.rm`.



# If an argument has a fixed set of possible parameters, you 
# should list them.
# If they are simple, list them in one sentence, like here in `stringr::str_trim()`:
#' @param side Side on which to remove whitespace: `"left"`, `"right"`, or 
#'    `"both"` (the default).


# If they need more explanation, use a bullet-ed list, as in `stringr::str_wrap()`:
#' @param whitespace_only A boolean.
#'  * `TRUE` (the default): wrapping will only occur at whitespace.
#'  * `FALSE`: can break on any non-word character (e.g. `/`, `-`).



### 16.3.1 Multiple arguments ----

# If the behavior of multiple arguments is tightly coupled, document them
# together by separating the names with commas (with no spaces).

# For example, in `stringr::str_equal()`, `x` and `y` are interchangeable,
# so they are documented together:
#' @param x,y A pair of character vectors.


# In `stringr::str_sub()`, `start` and `end` define the range of characters
# to replace.

# But instead of supplying both, you can use just `start` if you pass
# in a two-column matrix.

# So it makes sense to document `start` and `end` together:
#' @param start,end A pair of integer vectors defining the range of characters
#'  to extract (inclusive).
#'  
#'  Alternatively, instead of a pair of vectors, you can pass a matrix to
#'  `start`. The matrix should have two columns, either labelled `start`
#'  and `end`, or `start` and `legnth`.



# In `stringr::str_wrap()`, `indent` and `exdent` define the indentation
# for the first line and all subsequent lines, respectively:
#' @param indent,exdent A non-negative integer giving the indent for the
#'  first line (`indent`) and all subsequent lines (`exdent`).



### 16.3.2 Inheriting arguments ----

# "roxygen2" provides the `#' @inheritParams` tag which allows you
# to inherit the argument documentation from another function,
# possibly even in another package.


# "stringr" uses `@inheritParams` extensively because most functions
# have `string` and `pattern` arguments.

# The detailed and definitive documentation belongs to `stringr::str_detect()`:
#' @param string Input vector. Either a character vector, or something
#'  coercible to one.
#' @param pattern Pattern to look for
#' 
#'  The default interpretation is a regular expression, as described in the
#'  `vignette("regular-expressions")`. Use [regex()] for finer control of the
#'  matching behavior.
#'  
#'  Match a fixed string (i.e. by comparing only bytes), using 
#'  [fixed()]. This is fast, but approximative. Generally,
#'  for matching human text, you'll want to [coll()] which
#'  respects character matching rules for the specified locale.
#'  
#'  Match character, word, line, and sentence boundaries with
#'  [boundary()]. An empty pattern, "", is equivalent to
#'  `boundary("character")`.


# Then the other "stringr" functions use `@inheritParams str_detect`
# to get this detailed documentation for the `string` and `pattern`
# arguments.


# `@inheritParams` only inherits documentation for arguments that
# the function actually uses and that are not already documented.


# `stringr::str_match()` uses this to inherit `stringr::str_detect()`'s
# standard documentation for the `string` argument, 
# while providing its own specialized documentation for `pattern`:
#' @inheritParams str_detect
#' @param pattern Unlike other stringr functions, `str_match()` only supports
#'  regular expressions, as described by `vignette("regular-expressions")`.
#'  The pattern should contain at least one capturing group.



# You can inherit documentation from a function in another package
# by using the standard `package::function()` notation, i.e.
# `#' @inheritParams anotherpackage::function`.

# This introduces a small annoyance: The documentation for your
# package is no longer self-contained and the version of 
# "anotherpackage" can affect the generated documentation.


## 16.4 Return value ----

# Documenting the output of a function is the job of the
# `#' @returns` tag.

# The priority is to describe the overall "shape" of the output.

# If your function returns a vector, you might describe its type and length.

# If your function returns a data frame, you might want to describe
# the names and types of the columns and the expected number of rows.


# The `@returns` documentation for functions in the "stringr" package
# is straightforward because almost all fucntions return a vector of the smae
# length as one of the inputs, like `stringr::str_like()`:
#' @returns A logical vector the same length as `string`.



# The joing documentation for `stringr::str_locate()` and 
# `stringr::str_locate_all()` is more involved.

# `stringr::str_locate()` returns an integer matrix, and
# `stringr::str_locage_all()` returns a `list()` of matrices,
# so the text needs to describe what determines the rows and columns:
#' @returns 
#'  * `str_locate()` returns an integer matrix with two columns and
#'    one row for each element of `string`. The first column, `start`,
#'    gives the position at the start of the match, and the second column, `end`,
#'    gives the position of the end.
#'  
#'  * `str_locate_all()` returns a list of integer matrices with the same
#'    length as `string`/`pattern`. The matrices have columns `start` and `end`
#'    as above, and one row for each match.
#' @seealso 
#'  [str_extract()] for a convenient way of extracting matches
#'  [stringi::stri_locate()] for the underlying implementation.



# Sometimes it is easier to figure out what to highlight by
# thinking about the set of functions and how they differ.

# Most "dplyr" functions return a data frame, so just saying
# `@returns A data frame` is not useful.
# Instead, identify what makes each function different.

# Describe the function in terms of how it affects the rows, columns,
# groups, and attributes.

# The return value of `dplyr::filter()` is described as follows:
#' @returns 
#' An object of the same type as `.data`. The output has the following properties:
#' 
#'  * Rows are a subset of the input, but appear in the same order.
#'  * Columns are not modified.
#'  * The number of groups may be reduced (if `.preserve` is not `TRUE`).
#'  * Data frame attributes are preserved.



# `@returns` is also a good place to describe any important warnings or
# errors the user might see.

# `readr::read_csv()` mentions what happens if there are parsing problems:
#' @returns A [tibble()]. If there are parsing problems, a warning will alert you.
#'  You can retrieve the full details by calling [problems()] on your dataset.



# For your initial CRAN submission, all functions must document their
# return value.

# This may not be scrutinized in subsequent submissions, but it remains
# a best practice.

# There is currently no way to check that you have documented the
# return value of every function but the tidyverse team is working on it.



## 16.5 Examples ----

# The role of the `@examples` tag is to use executable R code
# to demonstrate what the function does.

# The example code must run without error and with no side effects
# such as when CRAN runs `R CMD check` or when your package
# website is built via GitHub Actions.


# The mechanics of examples are complex because they must never
# error and they are executed in four situations:

# 1) Interactively using the `example()` function.

# 2) During `R CMD check` on your computer, or another computer
#    you control, e.g. in GitHub Actions.

# 3) During `R CMD check` run by CRAN.

# 4) When your "pkgdown" website is being built, via GitHub Actions.


# In RStudio, when preparing `.R` scripts or `.Rmd`/`.qmd` reports,
# use Ctrl + Enter or the "Run" button to send a lien of R code to the
# console for execution.

# You can use the same workflow for executing and developing the
# `@examples` in your roxygen comments.


### 16.5.1 Contents ----

# Use examples ot show the basic operations of the functions first.
# Then show any particularly important properties.

# `stringr::str_detect()` starts by showing a few simple variations
# and then highlights a feature that is easy to miss:
# as well as passing a vector of strings and one pattern,
# you can also pass one string and a vector of patterns.
#' @examples
#' fruit <- c("apple", "banana", "pear", "pineapple")
#' str_detect(fruit, "a")
#' str_detect(fruit, "^a") 
#' str_detect(fruit, "a$")
#' 
#' # Also vectorised over pattern
#' str_detect("aecfg", letters)


# You can use sectioning comments with `---` to create a
# visual breakdown.

# An example form `tidyr::chop()` reads:
#' @examples
#' # Chop --------------------------------------------------------------
#' df <- tibble(x = c(1, 1, 1, 2, 2, 3), y = 1:6, z = 6:1)
#' # Note that we get one row of output for each unique combination of
#' # non-chopped variables
#' df %>% chop(c(y, z))
#' # cf nest
#' df %>% nest(data = c(y, z))
#' 
#' # Unchop -----------------------------------------------------------
#' df <- tibble(x = 1:4, y = list(integer(), 1L, 1:2, 1:3))
#' df %>% unchop(y)
#' df %>% unchop(y, keep_empty = TRUE)


# If you can make the point with a familiar built-in dataset,
# like `mtcars` do so.


### 16.5.2 Leave the world as you found it ----

# Your examples need to be self-contained. This means:

# - If you modify global `options()`, reset them at the end of the example.

# - If you create a file, crate it in `tempdir()` and delete it at the end of the example.

# - Do NOT change the working directory.

# - Do NOT write to the clipboard.


# Unfortunately, you can't use the "withr" package or even
# `base::on.exit()` to schedule clean up like restoring
# global options or deleting a file.

# Instead, you need to do this by hand.


# Note that all examples must run in under 10 minutes for your
# package to be submitted to CRAN.


### 16.5.3 Errors ----

# Your examples can NOT throw any errors.

# Avoid accessing websites, because `R CMD check` will fail whenever
# the website is down (like in a flaky test).


# There are two options if you need to include code that causes an error:

# - Wrap the code in a `try()` statement so that the error is shown,
#   but does not stop the execution of the exmaples.
#   `dplyr::bind_cols()` sues `try()` to show what happens if you attempt
#   to column-bind two data frames with different numbers of rows:
#' @examples
#' # ...
#' # Row sizes must be compatible when column-binding
#' try(bind_cols(tibble(x = 1:3), tibble(y = 1:2)))


# - You can wrap the code in `\dontrun{}`, so it is never run by
#   `example()`. The example from above would look like this:
#' # Row sizes must be compatible when column-binding
#' \dontrun{
#' bind_cols(tibble(x = 1:3), tibble(y = 1:2))
#' }


# We recommend using `try()` statements so the reader can see
# an example of the error in action.


# For the initial CRAN submission of your package, all functions
# must have at least one example and the example can NOT
# be wrapped inside of `\dontrun{}`.



### 16.5.4 Dependencies and conditional execution ----


# You can ONLY use packages in your examples that your new package 
# formally depends on, i.e. that appear in either the `Imports` or
# `Suggests` field of your `DESCRIPTION` file.


# Furthermore, example code is run in **the user's environment**,
# not the package environment, so you have to either
# explicitly attach the dependency with `library()` or
# refer to each function with `::`.

# "dbplyr"" is a "dplyr" extension package, so all of its examples
# start with `library(dplyr)`:
#' @examples
#' library(dplyr)
#' df <- data.frame(x = 1, y = 2)
#' 
#' df_sqlite <- tbl_lazy(df, con = simulate_sqlite())
#' df_sqlite %>% summarise(x = sd(x, na.rm = TRUE)) %>% show_query()



# In the past, we recommended only using code form suggested packages
# inside a block like this:
#' @examples
#' if (requrieNamespace("suggestedpackage", quietly = TRUE)) {
#'   # some example code
#' }


# We no longer recommend this practice, because:

# - The policy is to expect that suggested packages are installed
#   when running `R CMD check` and this informs what we do in examples,
#   tests, and vignettes.

# - The cost of putting example code inside of `{...}` is high:
#   you can no longer see intermediate results, such as when the examples
#   re rendered in the package's website.


# In other cases, your example code may depend on something other
# than a package.

# If your examples talk to a web API, you only want them to run
# for an authenticated user, and you NEVER want to run such
# code on CRAN.

# You need conditional execution like this:
#' @examples
#' if (some_condition()) {
#'   # some example code
#' }


# The condition could be quite general, such as `interactive()`, 
# which returns TRUE if R is being run interactively and FALSE otherwise,
# or very specific, such as a custom predicate function provided by your package.


# The `@examplesIf` tag is a great alternative to `@examples` here:
#' @examplesIf some_condition()
#' some_other_function()
#' some_more_functions()


# This has the following advantages:

# - Users won't see the `if() {...}` machinery when they read your
#   documentation form within R or on a "pkgdown" website.

# - The example code renders fully in "pkgdown".

# - The example code runs when it should and does not run when it shouldn't.

# - This does not run afoul fo CRAN's prohibition of putting all your example
#   code inside `\dontrun{}`.


# The "googledrive" apckage uses `@examplesIf` in almost every function,
# guarded by `googledrive::drive_has_token()`.


# The examples for `googledrive::drive_publish()` begin with:
#' @examplesIf drive_has_token()
#' # Create a file to publish
#' file <- drive_example_remote("chicken_sheet") %>%
#'   drive_cp()
#'   
#' # Publish file
#' file <- drive_publish(file)
#' # ...



# The example code does not run on the CRAN server, because
# it has no access token for the Google Drive API.

# It will run when "pkgdown" builds its website, because
# we can set up a token securely.

# And if a normal user calls this code, he or she will be prompted
# to sign in with Google.


### 16.5.5 Intermixing examples and text ----

# An alternative to examples is to use R Markdown code blocks 
# elsewhere in your roxygen comments, either ```R if you just
# want to show some code, or ```{r} if you want the code to be run.

# This strategy has the following downsides:

# - The code in ```R blocks is never run. You might not observe errors.

# - The code in ```{r} blocks is run every time you document the package.
#   This can take very long if used often.



## 16.6 Re-using documentation ----

# "roxygen2" provides a number of features that allow you to reuse documentaion
# across topics.

# They are documented in 
vignette("reuse", package = "roxygen2")

# The three most important topics are:

# - Documenting multiple functions in one topic.

# - Inheriting documentation from another topic.

# - Using child documents to share prose between topics,
#   or to share between documentation topics and vignettes.


### 16.6.1 Multiple functions in one topic ----

# The `stringr:.str_length()` and `stringr::str_width()` functions
# are just two different ways of computing the size of a string.

# It makes sense to document them to document them together:
#' The length/width of a string
#' 
#' @description
#' `str_length()` returns the number of codepoints in a string. They are
#' the individual elements (which are often, but not always letters) that
#' can be extracted with [str_sub()].
#' 
#' `str_width()` returns how much space the string will occupy when printed
#' in a fixed width font (i.e. when printed in the console).
#' 
#' # ...
str_length <- function(string) {
  # ...
}


# To merge the two topics, `stringr::st_width()` uses
# `@rdname st_length` to add its documentation to an existing topic:
#' @rdname str_length
str_width <- function(string) {
  # ...
}



### 16.6.2 Inheriting documentation ----

# In other cases, functions in a package might share many related
# behaviors, but are not closely enough connected that we would
# want to document them together.

# We have already discussed `@inheritParams`, and there are
# variations of it:

# - `@inherit source_function` will inherit all supported components form
#   `source_function()`.

# - `@inheritSection source_function Section title` will inherit the
#   single section with title "Section title" from `source_function()`.

# - `@inheritDotParams` automatically generates parameter documentaion for
#   `...` for the common case where you pass `...` on to the next function.


# See 
vignette("reuse", package = "roxygen2")
# for more details in the section "inheriting-documentation".



### 16.6.3 Child documents ----

# You can reuse the same `.Rmd` or `.md` document in the function 
# documentation, `README.Rmd`, and vignettes by using R Markdown 
# child documents with syntax like:
#' ```{r child = "man/rmd/filename.Rmd"}
#' ```


# In the "tidyverse" documentation, this feature is used very sparingly.

# Only in "dplyr" isit used frequently, since many functions use the
# same syntax as `select()`:
#' # Overview of selection features
#' 
#' ```{r, child = "man/rmd/overview.Rmd"}
#' ```

# Then `man/rmd/overview.Rmd` contains the repeated markdown:

# Tidyverse selections implement a dialect of R where operators make
# it easy to select variables:

# - `:` for selecting a range of consecutive variables.
# - `!` for taking the complement of a set of variables.
# - `&` and `|` for selecting the intersection or the union of two
#   sets of variables.
# - `c()` for combining selections.
# ...


# See the chapter "child-documents" in 
vignette("reuse", package = "roxygen2")
# for more details.



## 16.7 Help topic for the package ----

# Besides functions, you can document other R objects, as 
# detailed in 
vignette("rd-other", package = "roxygen2")

# In particular, you can create a help topic for the package
# itself by documenting the special
# sentinel `"_PACKAGE"`.

# The resulting `.Rd` file automatically pulls in information
# parsed form the `DESCRIPTION` file, 
# including title, description, list of authors, and useful URLs.

# This help topic appears alongside all your other topics and can be
# accessed with 
# `package?pkgname`, just like 
package?usethis
# or
?usethis


# Call `usethis::use_package_doc()` to set up this
# package-level documentation in a dummy file
# `pkg/R/{pkgname}-package.R`,
# whose contents look like:
#' @keywords internal
"_PACKAGE"

# The `pkg/R/{pkgname}-package.R` file can also serve as a 
# central location for import directives, i.e. for importing individual
# functions form your dependencies or even entire namespaces.


# In Chapter 11, we recommended importing specific functions with
# `usethis::use_import_from()` and this function is
# designed to write the associated roxygen tasks into the
# `pkg/R/{pkgname}-package.R` file created by `usethis::use_package_doc()`.


# A minimal example of the `pkg/R/{pkgname}-package.R` file might look like:
#' @keywords internal
"_PACKAGE"

# The following block is used by usethis to automatically manage
# roxygen namespace tags. Modify with care!
## usethis namespace: start
#' @importFrom glue glue_collapse
## usethis namespace: end
NULL



# The name "roxygen" is a nod to the Doxygen documentation generator
# which inspired the development of an R package named "roxygen".

# Then that package was rebooted as "roxygen2", similar to "ggplot2".


# Note that the `NAMESPACE` file is also generated from roxygen comments.

# Running `devtools::document()` also affects the field
# `RoxygenNote: 7.2.1` in the `DESCRIPTION` file.

# This records which version of "roxygen2" was last used in a package.


# END